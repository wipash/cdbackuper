apiVersion: v1
kind: Namespace
metadata:
  name: cd-import
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: cd-archive-pv
spec:
  capacity:
    storage: 1Ti
  accessModes: [ ReadWriteMany ]
  persistentVolumeReclaimPolicy: Retain
  storageClassName: ""           # <-- ADD THIS
  nfs:
    server: 172.20.0.1
    path: /volume1/Backup/Maurice/cd-archive
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: cd-archive-pvc
  namespace: cd-import
spec:
  accessModes: [ ReadWriteMany ]
  storageClassName: ""           # <-- ADD THIS
  resources:
    requests:
      storage: 1Ti
  volumeName: cd-archive-pv
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cd-watcher
  namespace: cd-import
data:
  cd-importer.sh: |
    #!/usr/bin/env bash
    set -Eeuo pipefail

    # --- Configuration via env (with defaults) -------------------------------
    DATA_ROOT="${DATA_ROOT:-/data}"         # PVC mount
    DEVICE_GLOB="${DEVICE_GLOB:-/dev/sr*}"  # CD/DVD devices to watch
    RETRIES="${RETRIES:-2}"                 # ddrescue retry passes
    TIMEOUT="${TIMEOUT:-7200}"              # seconds, per-disc guard
    EXTRACT_FILES="${EXTRACT_FILES:-true}"  # true|false
    POLL_SECS="${POLL_SECS:-5}"
    NODE_NAME="${NODE_NAME:-$(cat /etc/hostname)}"
    # -------------------------------------------------------------------------

    mkdir -p /var/run/cd-import /mnt/work

    log() { echo "[$(date -u +%FT%TZ)] $*"; }

    # FIX #4: Verify NFS mount at startup
    if ! mountpoint -q "$DATA_ROOT"; then
      log "FATAL: $DATA_ROOT is not mounted! Cannot proceed."
      exit 1
    fi
    log "Confirmed $DATA_ROOT is mounted."

    has_media() {
      local dev="$1"
      # ID_CDROM_MEDIA=1 is a good signal; fallback to blkid TYPE
      if udevadm info --query=property --name="$dev" 2>/dev/null | grep -q '^ID_CDROM_MEDIA=1$'; then
        return 0
      fi
      if blkid -o value -s TYPE "$dev" &>/dev/null; then
        return 0
      fi
      return 1
    }

    disc_label() {
      local dev="$1"
      blkid -o value -s LABEL "$dev" 2>/dev/null || echo "unknown"
    }

    dev_id() {
      local dev="$1"
      # Stable-ish ID via /dev/disk/by-id if present, else basename
      local path
      path=$(readlink -f "$dev")
      local byid
      byid=$(ls -1 /dev/disk/by-id/* 2>/dev/null | xargs -r -I{} bash -lc 'if [[ $(readlink -f "{}") == "'"$path"'" ]]; then basename "{}"; fi' | head -n1)
      [[ -n "${byid:-}" ]] && echo "$byid" || basename "$dev"
    }

    dump_metadata() {
      local dev="$1" dest="$2"
      blkid -o export "$dev" > "$dest/blkid.txt" 2>/dev/null || true
    }

    iso_info_dump() {
      local iso="$1" dest="$2"
      isoinfo -d -i "$iso" > "$dest/isoinfo.txt" 2>/dev/null || true
    }

    make_status() {
      local dest="$1" status="$2" msg="$3" iso="$4" started="$5" finished="$6"
      local rescued="" errors=""
      if [[ -f "$dest/ddrescue.log" ]]; then
        # quick parse summary if present
        rescued=$(grep -m1 'rescued:' "$dest/ddrescue.log" || true)
        errors=$(grep -m1 'errors:' "$dest/ddrescue.log" || true)
      fi
      jq -n --arg node "$NODE_NAME" \
            --arg status "$status" \
            --arg message "$msg" \
            --arg iso "$(basename "$iso")" \
            --arg started "$started" \
            --arg finished "$finished" \
            --arg rescued "$rescued" \
            --arg errors "$errors" \
            '{node:$node,status:$status,message:$message,iso:$iso,started:$started,finished:$finished,ddrescue:{rescued:$rescued,errors:$errors}}' \
        > "$dest/status.json"
    }

    process_disc() {
      local dev="$1"
      local started finished label id outdir iso loopmnt rc=0 timeout_pid

      # FIX #3: Clean mount point before use
      umount /mnt/work 2>/dev/null || true

      # FIX #3: Setup trap for cleanup
      cleanup_mount() {
        umount /mnt/work 2>/dev/null || true
      }
      trap cleanup_mount EXIT INT TERM

      label="$(disc_label "$dev" | tr -cd '[:alnum:]_. -' | tr ' ' '_')"
      started="$(date -u +%Y-%m-%dT%H%M%SZ)"

      outdir="$DATA_ROOT/$NODE_NAME/${started}_${label}"
      mkdir -p "$outdir"

      log "Processing $dev â†’ $outdir"
      dump_metadata "$dev" "$outdir"

      iso="$outdir/disc.iso"
      touch "$outdir/.in-progress"

      # FIX #2: Track timeout guard PID so we can kill it later
      (
        sleep "$TIMEOUT"
        if [[ -f "$outdir/.in-progress" ]]; then
          log "Timeout ($TIMEOUT s) hit for $dev; attempting to stop ddrescue and continue."
          pkill -f "ddrescue .* $dev" || true
        fi
      ) &
      timeout_pid=$!

      # ddrescue fast pass + a few retries
      set +e
      ddrescue -d -n "$dev" "$iso" "$outdir/ddrescue.log"
      ddrescue -d -r"$RETRIES" "$dev" "$iso" "$outdir/ddrescue.log"
      rc=$?
      set -e

      # FIX #2: Kill timeout guard if still running
      if kill -0 "$timeout_pid" 2>/dev/null; then
        kill "$timeout_pid" 2>/dev/null || true
        wait "$timeout_pid" 2>/dev/null || true
      fi

      iso_info_dump "$iso" "$outdir"

      # FIX #5: Check ISO integrity before attempting to mount/extract
      if [[ "${EXTRACT_FILES}" == "true" && -s "$iso" ]]; then
        if ! isoinfo -d -i "$iso" &>/dev/null; then
          log "ISO appears corrupt or unreadable, skipping file extraction"
        else
          mkdir -p "$outdir/files"
          # Mount the ISO read-only via loop and copy out
          if mount -o loop,ro "$iso" /mnt/work 2>/dev/null; then
            if mountpoint -q /mnt/work; then
              rsync -a /mnt/work/ "$outdir/files/" || true
              umount /mnt/work || true
            fi
          else
            log "Could not mount ISO to extract files (non-fatal)."
          fi
        fi
      fi

      finished="$(date -u +%Y%m%d-%H%M%S)"
      # Check if we recovered enough data to call it success
      rescued_pct="0"
      if [[ -f "$outdir/ddrescue.log" ]]; then
        rescued_line=$(grep 'rescued:' "$outdir/ddrescue.log" | tail -1 || true)
        # Extract percentage if available (crude parsing)
        rescued_pct=$(echo "$rescued_line" | grep -oP '\d+\.\d+(?=%)' || echo "0")
      fi

      # Consider >99% as success even if ddrescue returned error code
      if [[ $rc -eq 0 ]] || (( $(echo "$rescued_pct > 99" | bc -l 2>/dev/null || echo 0) )); then
        make_status "$outdir" "success" "Recovered $rescued_pct% (ddrescue rc=$rc)" "$iso" "$started" "$finished"
        log "SUCCESS for $dev (recovered $rescued_pct%)"
      else
        make_status "$outdir" "partial_or_failed" "ddrescue exited rc=$rc after retries, recovered $rescued_pct%" "$iso" "$started" "$finished"
        log "FAIL/PARTIAL for $dev (rc=$rc, rescued $rescued_pct%). See $outdir/status.json"
      fi


      rm -f "$outdir/.in-progress"
      sync || true
      eject "$dev" || true

      # Cleanup trap on normal exit
      trap - EXIT INT TERM
      cleanup_mount
    }

    # FIX #6: Track background jobs to avoid zombie accumulation
    declare -A active_jobs

    # Main loop
    log "Starting CD watcher on node $NODE_NAME. Devices: $DEVICE_GLOB"
    while true; do
      # Clean up finished jobs
      for pid in "${!active_jobs[@]}"; do
        if ! kill -0 "$pid" 2>/dev/null; then
          wait "$pid" 2>/dev/null || true
          unset active_jobs[$pid]
        fi
      done

      for dev in $DEVICE_GLOB; do
        [[ -e "$dev" ]] || continue
        lock="/var/run/cd-import/$(basename "$dev").lock"

        if has_media "$dev"; then
          # FIX #1: Atomic lock using mkdir instead of touch + check
          if mkdir "$lock" 2>/dev/null; then
            (
              process_disc "$dev" || true
              rmdir "$lock" 2>/dev/null || true
            ) &
            # FIX #6: Track the background job PID
            active_jobs[$!]="$dev"
            log "Started processing job $! for $dev"
          fi
        fi
      done
      sleep "$POLL_SECS"
    done

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: cd-importer
  namespace: cd-import
spec:
  selector:
    matchLabels: { app: cd-importer }
  template:
    metadata:
      labels: { app: cd-importer }
    spec:
      serviceAccountName: default
      hostPID: true
      hostIPC: true
      # Set fsGroup so NFS volumes are writable by group 65537
      securityContext:
        fsGroup: 65537
        fsGroupChangePolicy: "OnRootMismatch"
      containers:
      - name: watcher
        image: ghcr.io/wipash/cdbackuper:latest@sha256:1ce7d785c66946582f916b4771c187c79f344d4b3b00555bca3d6a56579024a9
        securityContext:
          privileged: true
          allowPrivilegeEscalation: true
          runAsGroup: 65537
          capabilities:
            add: ["SYS_ADMIN","SYS_RAWIO"]
        env:
          - name: NODE_NAME
            valueFrom:
              fieldRef: { fieldPath: spec.nodeName }
          - name: DATA_ROOT
            value: /data
          - name: RETRIES
            value: "2"
          - name: EXTRACT_FILES
            value: "true"
          - name: TIMEOUT
            value: "7200"
          - name: POLL_SECS
            value: "5"
        command: ["/usr/local/bin/cd-importer.sh"]
        volumeMounts:
          - name: host-dev
            mountPath: /dev
          - name: host-sys
            mountPath: /sys
            readOnly: true
          - name: udev-run
            mountPath: /run/udev
            readOnly: true
          - name: script
            mountPath: /usr/local/bin/cd-importer.sh
            subPath: cd-importer.sh
          - name: cd-archive
            mountPath: /data
      volumes:
        - name: host-dev
          hostPath: { path: /dev }
        - name: host-sys
          hostPath: { path: /sys }
        - name: udev-run
          hostPath: { path: /run/udev }
        - name: script
          configMap:
            name: cd-watcher
            defaultMode: 0755
        - name: cd-archive
          persistentVolumeClaim:
            claimName: cd-archive-pvc
      tolerations:
        - operator: "Exists"    # schedule everywhere
